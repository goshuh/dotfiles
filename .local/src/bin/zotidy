#!/usr/bin/python3

# /// script
# requires-python = "==3.13"
# dependencies = [
#   "chromadb",
#   "mcp",
#   "mistletoe"
# ]
# ///

import os
import sys

import re
import base64
import random
import sqlite3
import argparse

import dateutil.parser as dateparser

from typing import List, Literal, Dict


class Node(object):
    def __init__(self, i = None, doc = None, meta = None):
        self.id   = i    if i    else []
        self.doc  = doc  if doc  else []
        self.meta = meta if meta else []

    def append(self, i, doc, meta):
        self.id  .append(i)
        self.doc .append(doc)
        self.meta.append(meta)

    def get(self):
        b = 0

        while b < len(self.id):
            # there is a maximum batch size of 5461
            n = min(4096, len(self.id) - b)
            e = b + n

            yield Node(self.id  [b:e],
                       self.doc [b:e],
                       self.meta[b:e])
            b = e


class ChromaDB(object):
    def __init__(self, path, n):
        import chromadb

        self.path = os.path.join(path, 'chroma')
        self.nres = n

        self.conn = chromadb.PersistentClient(path = self.path)
        self.coll = self.conn.get_or_create_collection('default')

    def update(self, node):
        for n in node.get():
            for i in n.id:
                print(f'INFO: updating {i}')

            self.coll.upsert(documents = n.doc,
                             metadatas = n.meta,
                             ids       = n.id)
        return self

    def delete(self, node):
        for n in node.get():
            for i in n.id:
                print(f'INFO: deleting {i}')
                raise Exception

            self.coll.delete(where = {'key': {'$in': n.id}})

    async def query(self, query: List[str],
                    nres:      int         = 0,
                    where:     Dict | None = None,
                    where_doc: Dict | None = None):
        return self.coll.query(query_texts    = query,
                               n_results      = nres if nres else self.nres,
                               where          = where,
                               where_document = where_doc)

    async def get(self,
                  ids:       List[str] | None = None,
                  where:     Dict      | None = None,
                  where_doc: Dict      | None = None,
                  limit:     int       | None = None,
                  offset:    int       | None = None):
        return self.coll.get(ids            = ids,
                             where          = where,
                             where_document = where_doc,
                             limit          = limit,
                             offset         = offset)

    def get_items(self):
        return self.coll.get(include = [])['ids']

    # https://github.com/chroma-core/chroma-mcp/blob/main/src/chroma_mcp/server.py
    # https://gofastmcp.com/v2/patterns/decorating-methods
    def serve(self):
        import mcp.server.fastmcp as fastmcp

        mcp = fastmcp.FastMCP('chroma')

        mcp.tool()(self.query)
        mcp.tool()(self.get)

        mcp.run(transport = 'stdio')
        sys.exit(0)


class Markdown(object):
    # https://github.com/miyuchina/mistletoe/issues/262
    rend = None

    # level fix
    pat2 = re.compile('(?:' + '|'.join([
        # acm
        r'\d ',
        r'\d\. ',
        # ieee
        r'I\. ',   r'II\. ',   r'III\. ',   r'IV\. ',  r'V\. ',
        r'VI\. ',  r'VII\. ',  r'VIII\. ',  r'IX\. ',  r'X\. ',
        r'XI\. ',  r'XII\. ',  r'XIII\. ',  r'XIV\. ', r'XV\. ',
        r'XVI\. ', r'XVII\. ', r'XVIII\. ', r'XIX\. ', r'XX\. ',
        # common
        r'Abstract$',
        r'ABSTRACT$',
        r'Introduction$',
        r'INTRODUCTION$',
        r'Background$',
        r'BACKGROUND$',
        r'Related Work$',
        r'RELATED WORK$',
        r'Conclusions?$',
        r'CONCLUSIONS?$',
        r'Acknowledgements?$',
        r'ACKNOWLEDGEMENTS?$',
        r'References?$',
        r'REFERENCES?$'
    ]) + ')')

    pat3 = re.compile('(?:' + '|'.join([
        # acm
        r'\d\.\d ',
        r'\d\.\d\. ',
        # ieee
        r'[A-H]\. '
    ]) + ')')

    patz = re.compile('(?:' + '|'.join([
        # acm
        r'CCS Concepts$',
        r'CCS CONCEPTS$',
        r'Keywords$',
        r'KEYWORDS$',
        r'ACM Reference Format',
        r'ACM Reference format',
    ]) + ')')

    def __init__(self, file):
        import mistletoe
        import mistletoe.markdown_renderer as markdown_renderer

        self.pos  = ['' for _ in range(8)]
        self.tag  =  ''
        self.blks =  []
        self.segs =  []

        with open(file) as fd:
            self.doc  = mistletoe.Document(fd)

        if not Markdown.rend:
            Markdown.rend = markdown_renderer.MarkdownRenderer()

    def post(self):
        if not self.tag:
            self.blks = []
        if not self.blks:
            return

        self.segs.append((self.tag, self.blks))
        self.blks = []

    def get_text(self, node):
        if type(node).__name__ == 'RawText':
            return node.content

        if children := getattr(node, 'children', None):
            return ''.join(self.get_text(c) for c in children)

        return ''

    def walk(self, node):
        match type(node).__name__:
            case 'Heading':
                # level is not always correct
                text = self.get_text(node).strip()

                if not self.blks and not self.segs:
                    pos = 1
                elif Markdown.pat2.match(text):
                    pos = 2
                elif Markdown.pat3.match(text):
                    pos = 3
                elif Markdown.patz.match(text):
                    pos = 0
                else:
                    self.blks.append(f'{"#" * max(node.level, 4)} {text}')
                    return

                self.post()

                if pos:
                    self.pos[pos - 1] = text
                    self.tag = ' | '.join(self.pos[:pos])
                else:
                    self.tag = ''

            case 'Document':
                if children := getattr(node, 'children', None):
                    for c in children:
                        self.walk(c)

            case 'BlankLine':
                pass

            case _:
                self.blks.append(Markdown.rend.render(node).strip())

    def get(self):
        self.walk(self.doc)
        self.post()

        for c in self.segs:
            yield c


class ZoteroDB(object):
    def __init__(self, file):
        self.path = os.path.split(file)[0]

        try:
            self.conn = sqlite3.connect(file)
            self.conn.row_factory = sqlite3.Row
        except Exception as e:
            sys.exit(repr(e))

        self.curr = self.conn.cursor()

        self.creators = {}
        self.fields   = {}
        self.items    = {}

        for row in self.query('''
                SELECT creatorTypeID, creatorType
                FROM   creatorTypes
                '''):
            n = row['creatorType']
            i = row['creatorTypeID']

            self.creators[i] = n
            self.creators[n] = i

        for row in self.query('''
                SELECT fieldID, fieldName
                FROM   fieldsCombined
                '''):
            n = row['fieldName']
            i = row['fieldID']

            self.fields[i] = n
            self.fields[n] = i

        for row in self.query('''
                SELECT itemTypeID, typeName
                FROM   itemTypes
                '''):
            n = row['typeName']
            i = row['itemTypeID']

            self.items[i] = n
            self.items[n] = i

        # https://www.zotero.org/support/kb/attachment_title_vs_filename
        row = self.query('''
                SELECT valueID
                FROM   itemDataValues
                WHERE  value = ?
                ''', 'PDF')

        if not row:
            self.query('''
                    INSERT
                    INTO   itemDataValues (value)
                    VALUES (?)
                    ''', 'PDF')
            self.commit()

            self.pdf = self.curr.lastrowid
        else:
            self.pdf = next(iter(row))['valueID']

    def query(self, query, *args, one = False):
        select = query.lstrip().startswith('SELECT')

        if not select:
            print(f'INFO: perform ' +
                  ' '.join(query.replace('?', '{}').format(*args).split()))

        self.curr.execute(query, (*args, ))

        if select:
            if one:
                return self.curr.fetchone()
            else:
                return self.curr.fetchall()
        else:
            return []

    def get_item_year(self, date):
        if not date:
            return 'n/a'

        try:
            return str(dateparser.parse(date, fuzzy = True).year)
        except:
            pass

        # we only care about the year, which might come last
        for d in reversed(date.split()):
            try:
                return str(dateparser.parse(d, fuzzy = True).year)
            except:
                pass

        return 'n/a'

    def get_item_fields(self, iid):
        return {self.fields[row['fieldID']]: row['value']
                for row in self.query('''
                        SELECT d.fieldID, v.value
                        FROM   itemData       d
                        JOIN   itemDataValues v ON v.valueID = d.valueID
                        WHERE  itemID = ?
                        ''', iid)}

    def get_item_authors(self, iid):
        return [' '.join([row['firstName'], row['lastName']])
                for row in self.query('''
                        SELECT c.firstName, c.lastName
                        FROM   itemCreators i
                        JOIN   creators     c ON c.creatorID = i.creatorID
                        WHERE  i.itemID = ? AND i.creatorTypeID = ?
                        ORDER  BY i.orderIndex
                        ''', iid, self.creators['author'])]

    def get_item_annotations(self, iid):
        return [(row['itemID'], row['text'], row['comment'], row['pageLabel'])
                for row in self.query('''
                        SELECT a.itemID, a.text, a.comment, a.pageLabel
                        FROM   itemAnnotations a
                        JOIN   itemAttachments t ON t.itemID = a.parentItemID
                        WHERE  t.parentItemID = ?
                        ''', iid)]

    def get_item_attachments(self, iid):
        return [(row['itemID'], row['value'], row['valueID'],
                 row['path'  ], row['key'  ], row['synced' ])
                for row in self.query('''
                        SELECT a.itemID, v.valueID, v.value, a.path, i.key,
                               i.synced
                        FROM   itemAttachments a
                        JOIN   items           i ON i.itemID  = a.itemID
                        JOIN   itemData        d ON d.itemID  = a.itemID
                        JOIN   itemDataValues  v ON v.valueID = d.valueID
                        WHERE  a.parentItemID = ? AND d.fieldID = ?
                        ''', iid, self.fields['title'])]

    def get_item_notes(self, iid):
        return [(row['itemID'], row['title'], row['note'])
                for row in self.query('''
                        SELECT itemID, title, note
                        FROM   itemNotes
                        WHERE  parentItemID = ?
                        ''', iid)]

    def get_item_marker(self, top, key, dic):
        name = dic['path'].replace('storage:', '')

        if not (base := self.get_marker_path(key, name)):
            return

        file = os.path.join(base, name.replace('.pdf', '.md'))
        figs = {}

        if not os.path.isfile(file):
            return

        for f in os.listdir(base):
            # marker's convention
            if f.endswith('.jpeg'):
                with open(os.path.join(base, f), 'rb') as fd:
                    figs[f] = base64.b64encode(fd.read()).decode()

        print(f'INFO: parsing {file}')

        mark = Markdown(file)
        curr = []
        toks = 0

        for i, (tag, segs) in enumerate(mark.get()):
            # further split depending on tokens
            j = 0
            m = len(segs) - 1

            for k, s in enumerate(segs):
                l = len(s.split())

                curr.append(s)
                toks += l

                if toks < top and k < m:
                    continue

                # add a title
                ptag = f'{tag} | Part {j}'
                curr.insert(0, f'title: {ptag}\n\n-----')

                text = '\n\n'.join(curr)
                meta =  dic.copy()
                curr = [curr[-1]]
                toks =  l

                meta['key'] = key
                meta['tag'] = ptag

                for f in figs:
                    if f in text:
                        meta[f] = figs[f]

                yield f'{key}_{i}_{j}', text, meta

                j += 1

    def get_items(self):
        res = {}

        for row in self.query('''
                SELECT itemID, itemTypeID, key
                FROM   items
                WHERE  itemTypeID NOT IN (?, ?, ?)
                ''', self.items['annotation'],
                     self.items['attachment'],
                     self.items['note']):
            iid = row["itemID"]
            sub = res.setdefault(iid, {})

            etc = self.get_item_fields(iid)

            sub['title'      ] = etc.get('title')
            sub['venue'      ] = etc.get('conferenceName', '')
            sub['series'     ] = etc.get('series',         '')
            sub['year'       ] = self.get_item_year(etc.get('date', ''))
            sub['authors'    ] = self.get_item_authors(iid)
            sub['type'       ] = self.items[row['itemTypeID']]

            sub['notes'      ] = {nid:
                {'title': t, 'note': c}
                    for nid, t, c          in self.get_item_notes(iid)}
            sub['annotations'] = {aid:
                {'text':  t, 'note': c, 'page': p}
                    for aid, t, c, p       in self.get_item_annotations(iid)}
            sub['attachments'] = {aid:
                {'title': t, 'path': p, 'key':  k, 'vid': v, 'synced': s}
                    for aid, t, v, p, k, s in self.get_item_attachments(iid)}

        return res

    def get_marker_path(self, key, name):
        base = os.path.join(self.path, 'marker', key)

        if not os.path.isdir(base):
            # marker's convention
            orig = os.path.join(self.path, 'marker', name.replace('.pdf', ''))

            if not os.path.isdir(orig):
                return ''

            print(f'INFO: renaming {orig} -> {base}')
            os.rename(orig, base)

        return base

    def get_random_key(self):
        return ''.join(random.choices('23456789ABCDEFGHIJKLMNPQRSTUVWXYZ',
                                      k = 8))

    def output_items(self):
        for iid, dic in self.get_items().items():
            print(f'#{iid}')
            print(f'  Year:    {dic["year" ]}')
            print(f'  Title:   {dic["title"]}')
            print(f'  Venue:   {dic["venue"]}')
            print(f'  Authors: {", ".join(dic["authors"])}')

            for nid, d in dic['notes'].items():
                print(f'  Note #{nid}')
                print(f'    Title: {d["title"]}')
                print(f'    Note:  {d["note" ]}')

            for aid, d in dic['attachments'].items():
                print(f'  Attachment #{aid}')
                print(f'    Title: {d["title"]}')
                print(f'    Path:  {d["path" ]}')
                print(f'    Key:   {d["key"  ]}')

            for aid, d in dic['annotations'].items():
                print(f'  Annotation #{aid}')
                print(f'    Text:  {d["text" ]}')
                print(f'    Note:  {d["note" ]}')
                print(f'    Page:  {d["page" ]}')

            print()

    def update_attachment_title(self, vid, t, aid):
        # the vid (and the associated value) is unique, but there can be
        # multiple references to it
        row = self.query('''
                SELECT COUNT(*) AS cnt
                FROM   itemData
                WHERE  valueID = ?
                ''', vid, one = True)

        if row['cnt'] == 1:
            self.query('''
                    DELETE
                    FROM   itemDataValues
                    WHERE  valueID = ?
                    ''', vid)

        self.query('''
                UPDATE itemData
                SET    valueID = ?
                WHERE  fieldID = ? AND itemID = ?
                ''', self.pdf, self.fields['title'], aid)

    def rename_attachment_all(self, ref):
        for iid, dic in self.get_items().items():
            sync = False

            if len(dic['attachments']) != 1:
                continue

            aid, d = next(iter(dic['attachments'].items()))

            path = d['path']

            if not path.startswith('storage:'):
                print(f'WARNING: attachment {d["key"]}: {d["path"]}')
                continue

            file = path.replace('storage:', '')
            path = os.path.join(self.path, 'storage', d['key'])

            if ref and os.path.isdir(path):
                for f in os.listdir(path):
                    if not f.endswith('.pdf'):
                        continue
                    if f == file:
                        continue

                    sync = True
                    file = f

                    self.query('''
                            UPDATE itemAttachments
                            SET    path   = ?
                            WHERE  itemID = ?
                            ''', f'storage:{f}', aid)
                    break

            if d['vid'] != self.pdf:
                sync = True
                self.update_attachment_title(d['vid'], d['title'], aid)

            if sync and d['synced'] == 1:
                self.query('''
                        UPDATE items
                        SET    synced = ?
                        WHERE  itemID = ?
                        ''', 0, aid)

        # extra value cleanup
        rows = self.query('''
                SELECT valueID, value
                FROM   itemDataValues
                WHERE  valueID NOT IN (SELECT valueID FROM itemData)
                ''')

        for row in rows:
            print(f'INFO: dangling value {row["valueID"]}: {row["value"]}')

        if rows:
            self.query('''
                    DELETE
                    FROM  itemDataValues
                    WHERE valueID NOT IN (SELECT valueID FROM itemData)
                    ''')

        self.commit()

    def rename_attachment_one(self, key, file):
        row = self.query('''
                SELECT i.itemID, d.valueID, a.path, i.synced
                FROM   items           i
                JOIN   itemData        d ON d.itemID = i.itemID
                JOIN   itemAttachments a ON a.itemID = i.itemID
                WHERE  i.key = ? AND d.fieldID = ?
                ''', key, self.fields['title'], one = True)

        if row['path'].replace('storage:', '') != file:
            self.query('''
                    UPDATE itemAttachments
                    SET    path   = ?
                    WHERE  itemID = ?
                    ''', f'storage:{file}', row['itemID'])

        if row['valueID'] != self.pdf:
            self.update_attachment_title(row['valueID'], '', row['itemID'])

        if row['synced']:
            self.query('''
                    UPDATE items
                    SET    synced = ?
                    WHERE  itemID = ?
                    ''', 0, row['itemID'])

        self.commit()

    def ensure_venue(self, upd, ven, cid):
        if ven:
            row = self.query('''
                    SELECT collectionID
                    FROM   collections
                    WHERE  collectionName = ? AND parentCollectionID = ?
                    ''', ven, cid, one = True)

            if row:
                return row['collectionID']

            self.query('''
                    INSERT
                    INTO   collections (collectionName, parentCollectionID,
                                        libraryID, key, version, synced)
                    VALUES (?, ?, ?, ?, ?, ?)
                    ''', ven, cid, 1, self.get_random_key(), 1, 0)

            self.commit()

        if cid not in upd:
            upd.add(cid)

            self.query('''
                    UPDATE collections
                    SET    synced = ?
                    WHERE  collectionID = ?
                    ''', 0, cid)

        return self.curr.lastrowid

    def venue(self, exts):
        cat = {
            'ISCA':
                '''Symposium on Computer Architecture''',
            'ASPLOS':
                '''Conference on Architectural Support for Programming Languages
                   and Operating Systems''',
            'MICRO':
                '''Symposium on Microarchitecture''',
            'HPCA':
                '''Symposium on High-Performance Computer Architecture''',
            'SOSP':
                '''Symposium on Operating Systems Principles''',
            'OSDI':
                '''Symposium on Operating Systems Design and Implementation''',
            'EuroSys':
                '''European Conference on Computer Systems''',
            'USENIX ATC':
                '''USENIX Annual Technical Conference''',
            'SIGCOMM':
                '''''',
            'NSDI':
                '''Symposium on Networked SYstems Design and Implementation''',
            'IISWC':
                '''Symposium on Workload Characterization''',
            'ISPASS':
                '''Symposium on Performance Analysis of Systems and Software'''
        }

        ves = {}
        upd = set()

        cat = {k: ' '.join(v.split()).lower() for k, v in cat.items()}
        cat.update({e: '' for e in exts})

        top = self.query('''
                SELECT collectionID
                FROM   collections
                WHERE  collectionName = ?
                ''', 'Venue', one = True)['collectionID']

        for c in cat:
            ves[c] = self.ensure_venue(upd, c, top)

        for iid, dic in self.get_items().items():
            if dic['type'] != 'conferencePaper':
                continue

            ven = dic['venue']
            ser = dic['series']
            vel = ven.lower()
            now = ''

            for c, f in cat.items():
                if c in ven or c in ser or (f and f in vel):
                    ven = c
                    now = dic['year']
                    break

            if not now:
                continue

            print(f'INFO: adding {dic["title"]} to {ven}/{now}')

            van = f'{ven}_{now}'
            cid = ves.get(van, 0)

            if not cid:
                cid = ves[van] = self.ensure_venue(upd, now, ves[ven])

            if not self.query('''
                    SELECT COUNT(*) AS cnt
                    FROM   collectionItems
                    WHERE  collectionID = ? AND itemID = ?
                    ''', cid, iid, one = True)['cnt']:
                idx = self.query('''
                        SELECT IFNULL(MAX(orderIndex) + 1, 0) AS idx
                        FROM   collectionItems
                        WHERE  collectionID = ?
                        ''', cid, one = True)['idx']

                self.query('''
                        INSERT
                        INTO   collectionItems (collectionID, itemID,
                                                orderIndex)
                        VALUES (?, ?, ?)
                        ''', cid, iid, idx)

                self.query('''
                        UPDATE items
                        SET    synced = ?
                        WHERE  itemID = ?
                        ''', 0, iid)

                self.ensure_venue(upd, '', cid)

        self.commit()

    def marker(self, exts):
        new = set()
        cat = ['conferencePaper', 'journalArticle', 'preprint',
               'report', 'patent']
        cat.extend(exts)

        for dic in self.get_items().values():
            if dic['type'] not in cat:
                continue

            for att in dic['attachments'].values():
                new.add(att['key'])

                name = att['path'].replace('storage:', '')

                file = os.path.join(self.path, 'storage', att['key'], name)
                base = os.path.join(self.get_marker_path (att['key'], name),
                                    name.replace('.pdf', '.md'))

                if os.path.isfile(file) and not os.path.isfile(base):
                    print(file)

        base = os.path.join(self.path, 'marker')

        if os.path.isdir(base):
            for d in os.listdir(base):
                full = os.path.join(base, d)

                if os.path.isdir(full) and d not in new:
                    print(f'INFO: removing {full}')
                    os.rename(full, os.path.join(base, f'DELETED-{d}'))

    def update_chroma(self, back, top, aks, sks):
        old = back.get_items() if not aks or not sks else {}
        new = {}

        for dic in self.get_items().values():
            for att in dic['attachments'].values():
                cur = new.setdefault(att.pop('key'), {})

                cur['type'   ] = dic['type' ]
                cur['year'   ] = dic['year' ]
                cur['title'  ] = dic['title']
                cur['venue'  ] = dic['venue']
                cur['authors'] = ', '.join(dic['authors'])
                cur['path'   ] = att['path' ]

        add = Node()
        sub = Node()

        if aks:
            for i in aks:
                if i in new:
                    for e in self.get_item_marker(top, i, new[i]):
                        add.append(*e)
        else:
            for i in new:
                if f'{i}_0_0' not in old:
                    for e in self.get_item_marker(top, i, new[i]):
                        add.append(*e)

        if sks:
            for i in sks:
                sub.append(i, '', {})
        else:
            for i in old:
                if (j := i.split('_')[0]) not in new:
                    sub.append(j, '', {})

        back.update(add)
        back.delete(sub)

    def commit(self):
        self.conn.commit()

    def close(self):
        self.conn.close()


def parse_args():
    parser = argparse.ArgumentParser(description = 'zotidy')
    parser.add_argument('-z', required = True)

    s = parser.add_subparsers(dest = 'command', required = True)

    l = s.add_parser('list')
    r = s.add_parser('rename')
    v = s.add_parser('venue')
    c = s.add_parser('chroma')

    r.add_argument('-a', action = 'store_true')
    r.add_argument('-r', action = 'store_true')
    r.add_argument('-k')
    r.add_argument('-f')

    v.add_argument('-c', nargs  = '*',  default = [])

    c.add_argument('-m', action = 'store_true')
    c.add_argument('-u', action = 'store_true')
    c.add_argument('-c', nargs  = '*',  default = [])
    c.add_argument('-n', type   =  int, default = 2)
    c.add_argument('-t', type   =  int, default = 1024)
    c.add_argument('-a', nargs  = '*',  default = [])
    c.add_argument('-d', nargs  = '*',  default = [])

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    z = ZoteroDB(args.z)

    match args.command:
        case 'list':
            z.output_items()

        case 'rename':
            if args.a:
                z.rename_attachment_all(args.r)
            elif args.k and args.f:
                z.rename_attachment_one(args.k, args.f)
            else:
                sys.exit('ERROR: invalid rename command')

        case 'venue':
            z.venue(args.c)

        case 'chroma':
            if args.m:
                z.marker(args.c)
            elif args.u:
                z.update_chroma(ChromaDB(z.path, args.n), args.t,
                                args.a, args.d)
            else:
                z.close()
                ChromaDB(z.path, args.n).serve()

    z.close()
