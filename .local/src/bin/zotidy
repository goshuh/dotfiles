#!/usr/bin/python3

# /// script
# requires-python = "3.13"
# de"endencies = [
#   "chromadb",
#   "mcp"
# ]
# ///

import os
import sys

import base64
import sqlite3
import argparse

from typing import List, Literal, Dict


class Node:
    def __init__(self):
        self.id   = []
        self.doc  = []
        self.meta = []

    def append(self, i, doc, meta):
        self.id  .append(i)
        self.doc .append(doc)
        self.meta.append(meta)


class ChromaDB:
    def __init__(self, path, n):
        import chromadb

        self.path = path
        self.nres = n

        self.conn = chromadb.PersistentClient(path = path)
        self.coll = self.conn.get_or_create_collection('default')

    def update(self, node):
        self.coll.upsert(documents = node.doc,
                         metadatas = node.meta,
                         ids       = node.id)
        return self

    def delete(self, node):
        self.coll.delete(ids = node.id)

    async def query(self, query: List[str],
                    nres:      int         = 0,
                    where:     Dict | None = None,
                    where_doc: Dict | None = None):
        return self.coll.query(query_texts    = query,
                               n_results      = nres if nres else self.nres,
                               where          = where,
                               where_document = where_doc)

    async def get(self,
                  ids:       List[str] | None = None,
                  where:     Dict      | None = None,
                  where_doc: Dict      | None = None,
                  limit:     int       | None = None,
                  offset:    int       | None = None):
        return self.coll.get(ids            = ids,
                             where          = where,
                             where_document = where_doc,
                             limit          = limit,
                             offset         = offset)

    def get_items(self):
        return self.coll.get(include = [])

    # https://github.com/chroma-core/chroma-mcp/blob/main/src/chroma_mcp/server.py
    # https://gofastmcp.com/v2/patterns/decorating-methods
    def serve(self):
        import mcp.server.fastmcp as fastmcp

        mcp = fastmcp.FastMCP('chroma')

        mcp.tool()(self.query)
        mcp.tool()(self.get)

        mcp.run(transport = 'stdio')
        sys.exit(0)


class ZoteroDB:
    def __init__(self, file, dry):
        self.path = os.path.split(file)[0]
        self.dry  = dry

        try:
            self.conn = sqlite3.connect(file)
            self.conn.row_factory = sqlite3.Row
        except Exception as e:
            sys.exit(repr(e))

        self.curr = self.conn.cursor()

        self.creators = {}
        self.fields   = {}
        self.items    = {}

        for row in self.query("""
                SELECT creatorTypeID, creatorType
                FROM   creatorTypes
                """):
            n = row['creatorType']
            i = row['creatorTypeID']

            self.creators[i] = n
            self.creators[n] = i

        for row in self.query("""
                SELECT fieldID, fieldName
                FROM   fieldsCombined
                """):
            n = row['fieldName']
            i = row['fieldID']

            self.fields[i] = n
            self.fields[n] = i

        for row in self.query("""
                SELECT itemTypeID, typeName
                FROM   itemTypes
                """):
            n = row['typeName']
            i = row['itemTypeID']

            self.items[i] = n
            self.items[n] = i

        # https://www.zotero.org/support/kb/attachment_title_vs_filename
        row = self.query("""
                SELECT valueID
                FROM   itemDataValues
                WHERE  value = ?
                """, 'PDF')

        if not row:
            self.query("""
                    INSERT
                    INTO   itemDataValues (value)
                    VALUES (?)
                    """, 'PDF')

            self.pdf = self.curr.lastrowid
        else:
            self.pdf = next(iter(row))['valueID']

    def query(self, query, *args, one = False):
        select = query.lstrip().startswith('SELECT')

        if not select:
            print(f'INFO: perform ' +
                  ' '.join(query.replace('?', '{}').format(*args).split()))

        if not self.dry or select:
            self.curr.execute(query, (*args, ))

        if select:
            if one:
                return self.curr.fetchone()
            else:
                return self.curr.fetchall()
        else:
            return []

    def get_item_fields(self, iid):
        return {self.fields[row['fieldID']]: row['value']
                for row in self.query("""
                        SELECT d.fieldID, v.value
                        FROM   itemData       d
                        JOIN   itemDataValues v ON v.valueID = d.valueID
                        WHERE  itemID = ?
                        """, iid)}

    def get_item_authors(self, iid):
        return [' '.join([row['firstName'], row['lastName']])
                for row in self.query("""
                        SELECT c.firstName, c.lastName
                        FROM   itemCreators i
                        JOIN   creators     c ON c.creatorID = i.creatorID
                        WHERE  i.itemID = ? AND i.creatorTypeID = ?
                        ORDER  BY i.orderIndex
                        """, iid, self.creators['author'])]

    def get_item_annotations(self, iid):
        return [(row['itemID'], row['text'], row['comment'], row['pageLabel'])
                for row in self.query("""
                        SELECT a.itemID, a.text, a.comment, a.pageLabel
                        FROM   itemAnnotations a
                        JOIN   itemAttachments t ON t.itemID = a.parentItemID
                        WHERE  t.parentItemID = ?
                        """, iid)]

    def get_item_attachments(self, iid):
        return [(row['itemID'], row['value'], row['valueID'],
                 row['path'  ], row['key'  ], row['synced' ])
                for row in self.query("""
                        SELECT a.itemID, v.valueID, v.value, a.path, i.key, i.synced
                        FROM   itemAttachments a
                        JOIN   items           i ON i.itemID  = a.itemID
                        JOIN   itemData        d ON d.itemID  = a.itemID
                        JOIN   itemDataValues  v ON v.valueID = d.valueID
                        WHERE  a.parentItemID = ? AND d.fieldID = ?
                        """, iid, self.fields['title'])]

    def get_item_notes(self, iid):
        return [(row['itemID'], row['title'], row['note'])
                for row in self.query("""
                        SELECT itemID, title, note
                        FROM   itemNotes
                        WHERE  parentItemID = ?
                        """, iid)]

    def get_item_marker(self, key, dic):
        name = dic['path'].replace('storage:', '')

        if not (base := self.get_marker_path(key, name)):
            return None

        file = os.path.join(base, name.replace('.pdf', '.md'))

        if not os.path.isfile(file):
            return None

        with open(file) as fd:
            file = fd.read()

        for f in os.listdir(base):
            # marker's convention
            if f.endswith('.jpeg'):
                with open(os.path.join(base, f), 'rb') as fd:
                    dic[f] = base64.b64encode(fd.read()).decode()

        return file, dic

    def get_items(self):
        res = {}

        for row in self.query("""
                SELECT itemID, itemTypeID, key
                FROM   items
                WHERE  itemTypeID NOT IN (?, ?, ?)
                """, self.items['annotation'],
                     self.items['attachment'],
                     self.items['note']):
            iid = row["itemID"]
            sub = res.setdefault(iid, {})

            etc = self.get_item_fields(iid)

            sub['date'       ] = etc.get('date', '')
            sub['title'      ] = etc.get('title')
            sub['authors'    ] = self.get_item_authors(iid)
            sub['type'       ] = self.items[row['itemTypeID']]

            sub['notes'      ] = {nid:
                {'title': t, 'note': c}
                    for nid, t, c          in self.get_item_notes(iid)}
            sub['annotations'] = {aid:
                {'text':  t, 'note': c, 'page': p}
                    for aid, t, c, p       in self.get_item_annotations(iid)}
            sub['attachments'] = {aid:
                {'title': t, 'path': p, 'key':  k, 'vid': v, 'synced': s}
                    for aid, t, v, p, k, s in self.get_item_attachments(iid)}

        return res

    def get_marker_path(self, key, name):
        base = os.path.join(self.path, 'marker', key)

        if not os.path.isdir(base):
            # marker's convention
            orig = os.path.join(self.path, 'marker', name.replace('.pdf', ''))

            if not os.path.isdir(orig):
                return ''

            print(f'INFO: renaming {orig} -> {base}')
            os.rename(orig, base)

        return base

    def output_items(self):
        for iid, dic in self.get_items().items():
            print(f'#{iid}')
            print(f'  Date:    {dic["date" ]}')
            print(f'  Title:   {dic["title"]}')
            print(f'  Authors: {", ".join(dic["authors"])}')

            for nid, d in dic['notes'].items():
                print(f'  Note #{nid}')
                print(f'    Title: {d["title"]}')
                print(f'    Note:  {d["note" ]}')

            for aid, d in dic['attachments'].items():
                print(f'  Attachment #{aid}')
                print(f'    Title: {d["title"]}')
                print(f'    Path:  {d["path" ]}')
                print(f'    Key:   {d["key"  ]}')

            for aid, d in dic['annotations'].items():
                print(f'  Annotation #{aid}')
                print(f'    Text:  {d["text" ]}')
                print(f'    Note:  {d["note" ]}')
                print(f'    Page:  {d["page" ]}')

            print()

    def update_attachment_title(self, vid, t, aid):
        # the vid (and the associated value) is unique, but there can be
        # multiple references to it
        row = self.query("""
                SELECT COUNT(*) as cnt
                FROM   itemData
                WHERE  valueID = ?
                """, vid, one = True)

        if row['cnt'] == 1:
            self.query("""
                    DELETE
                    FROM   itemDataValues
                    WHERE  valueID = ?
                    """, vid)

        self.query("""
                UPDATE itemData
                SET    valueID = ?
                WHERE  fieldID = ? AND itemID = ?
                """, self.pdf, self.fields['title'], aid)

    def rename_attachment_all(self, ref):
        for iid, dic in self.get_items().items():
            sync = False

            if len(dic['attachments']) != 1:
                continue

            aid, d = next(iter(dic['attachments'].items()))

            path = d['path']

            if not path.startswith('storage:'):
                print(f'WARNING: attachment {d["key"]}: {d["path"]}')
                continue

            file = path.replace('storage:', '')
            path = os.path.join(self.path, 'storage', d['key'])

            if ref and os.path.isdir(path):
                for f in os.listdir(path):
                    if not f.endswith('.pdf'):
                        continue
                    if f == file:
                        continue

                    sync = True
                    file = f

                    self.query("""
                            UPDATE itemAttachments
                            SET    path   = ?
                            WHERE  itemID = ?
                            """, f'storage:{f}', aid)
                    break

            if d['vid'] != self.pdf:
                sync = True
                self.update_attachment_title(d['vid'], d['title'], aid)

            if sync and d['synced'] == 1:
                self.query("""
                        UPDATE items
                        SET    synced = ?
                        WHERE  itemID = ?
                        """, 0, aid)

        # extra value cleanup
        rows = self.query("""
                SELECT valueID, value
                FROM   itemDataValues
                WHERE  valueID NOT IN (SELECT valueID FROM itemData)
                """)

        for row in rows:
            print(f'INFO: dangling value {row["valueID"]}: {row["value"]}')

        if rows:
            self.query("""
                    DELETE
                    FROM  itemDataValues
                    WHERE valueID NOT IN (SELECT valueID FROM itemData)
                    """)

        if not self.dry:
            self.commit()

    def rename_attachment_one(self, key, file):
        row = self.query("""
                SELECT i.itemID, d.valueID, a.path, i.synced
                FROM   items           i
                JOIN   itemData        d ON d.itemID = i.itemID
                JOIN   itemAttachments a ON a.itemID = i.itemID
                WHERE  i.key = ? AND d.fieldID = ?
                """, key, self.fields['title'])

        if row['path'].replace('storage:', '') != file:
            self.query("""
                    UPDATE itemAttachments
                    SET    path   = ?
                    WHERE  itemID = ?
                    """, f'storage:{file}', key)

        if row['valueID'] != self.pdf:
            self.update_attachment_title(row['valueID'], '', row['itemID'])

        if row['synced']:
            self.query("""
                    UPDATE items
                    SET    synced = ?
                    WHERE  itemID = ?
                    """, 0, row['itemID'])

        if not self.dry:
            self.commit()

    def marker(self, exts):
        new = set()
        cat = ['conferencePaper', 'journalArticle', 'preprint']
        cat.extend(exts)

        for dic in self.get_items().values():
            if dic['type'] not in cat:
                continue

            for att in dic['attachments'].values():
                new.add(att['key'])

                name = att['path'].replace('storage:', '')

                file = os.path.join(self.path, 'storage', att['key'], name)
                base = os.path.join(self.get_marker_path (att['key'], name),
                                    name.replace('.pdf', '.md'))

                if os.path.isfile(file) and not os.path.isfile(base):
                    print(file)

        base = os.path.join(self.path, 'marker')

        if os.path.isdir(base):
            for d in os.listdir(base):
                if d not in new:
                    full = os.path.join(base, d)

                    print(f'INFO: removing {full}')
                    os.rename(full, os.path.join(base, f'DELETED-{d}'))

    def update_chroma(self, back, aks, sks):
        old = back.get_items() if not aks or not sks else {}
        new = {}

        for dic in self.get_items().values():
            for att in dic['attachments'].values():
                cur = new.setdefault(att.pop('key'), {})

                cur['type'   ] = dic['type' ]
                cur['date'   ] = dic['date' ]
                cur['title'  ] = dic['title']
                cur['path'   ] = att['path' ]
                cur['authors'] = ', '.join(dic['authors'])

        add = Node()
        sub = Node()

        if aks:
            for i in aks:
                if i in new:
                    if ret := self.get_item_marker(i, new[i]):
                        add.append(i, *ret)
        else:
            for i in new:
                if i not in old:
                    if ret := self.get_item_marker(i, new[i]):
                        add.append(i, *ret)

        if sks:
            for i in sks:
                sub.append(i, '', {})
        else:
            for i in old:
                if i not in new:
                    sub.append(i, '', {})

        back.update(add)
        back.delete(sub)

    def commit(self):
        self.conn.commit()

    def close(self):
        self.conn.close()


def parse_args():
    parser = argparse.ArgumentParser(description = 'zotidy')
    parser.add_argument('-z', required =  True)
    parser.add_argument('-d', action   = 'store_true')

    s = parser.add_subparsers(dest = 'command', required = True)

    l = s.add_parser('list')
    r = s.add_parser('rename')
    c = s.add_parser('chroma')

    r.add_argument('-a', action = 'store_true')
    r.add_argument('-r', action = 'store_true')
    r.add_argument('-k')
    r.add_argument('-f')

    c.add_argument('-m', action = 'store_true')
    c.add_argument('-s', action = 'store_true')
    c.add_argument('-c', nargs  = '*',  default = [])
    c.add_argument('-p')
    c.add_argument('-n', type   =  int, default = 2)
    c.add_argument('-a', nargs  = '*',  default = [])
    c.add_argument('-d', nargs  = '*',  default = [])

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()

    z = ZoteroDB(args.z, args.d)

    match args.command:
        case 'list':
            z.output_items()

        case 'rename':
            if args.a:
                z.rename_attachment_all(args.r)
            elif args.i and args.f:
                z.rename_attachment_one(args.k, args.f)
            else:
                sys.exit('ERROR: invalid rename command')

        case 'chroma':
            if args.m:
                z.marker(args.c)
            elif args.s and args.p:
                ChromaDB(args.p, args.n).serve()
            elif args.p:
                z.update_chroma(ChromaDB(args.p, args.n), args.a, args.d)
            else:
                sys.exit('ERROR: invalid chroma command')

    z.close()
